<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Christoph Garwe, Philipp Meyer, Laura Brune und Christoph Hönnige, Institut für Politikwissenschaft, Leibniz Universität Hannover" />


<title>Politikwissenschaftliche Statistik mit R - Sitzung 4: Variablen um-/kodieren</title>

<script src="site_libs/header-attrs-2.7/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-sm-12 col-md-4 col-lg-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-sm-12 col-md-8 col-lg-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Politikwissenschaftliche Statistik mit R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">(0) Willkommen</a>
</li>
<li>
  <a href="Sitzung_1_Einfuehrung.html">(1) Grundlagen</a>
</li>
<li>
  <a href="Sitzung_2_Faktoren_und_Zweidimensionale_Objekte.html">(2) Faktoren &amp; Objekte</a>
</li>
<li>
  <a href="Sitzung_3_Datensaetze_einladen.html">(3) Datensätze</a>
</li>
<li>
  <a href="Sitzung_4_Variablen_Kodieren.html">(4) Variablen</a>
</li>
<li>
  <a href="Sitzung_5_univariate_Maße.html">(5) Univariate Maße</a>
</li>
<li>
  <a href="Sitzung_6_Visualisierung_I.html">(6) Visualisierung I</a>
</li>
<li>
  <a href="Sitzung_7_bivariate_Zusammenhangsmaße.html">(7) Bivariate Maße</a>
</li>
<li>
  <a href="Sitzung_8_bivariate_OLS.html">(8) Lineare Regression</a>
</li>
<li>
  <a href="Sitzung_9_Visualisierung_II.html">(9) Visualisierung II</a>
</li>
<li>
  <a href="Sitzung_10_multiple_lineare_Regression.html">(10) Multiple Regression</a>
</li>
<li>
  <a href="Sitzung_11_LogitReg.html">(11) Logistische Regression</a>
</li>
<li>
  <a href="Sitzung_12_Faktoranalyse.html">(12) Faktoranalyse</a>
</li>
<li>
  <a href="Sitzung_13_Tabellen.html">(13) Visualisierung III</a>
</li>
<li>
  <a href="Sitzung_14_Loesungen.html">(14) Lösungen</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Politikwissenschaftliche Statistik mit R - Sitzung 4: Variablen um-/kodieren</h1>
<h4 class="author">Christoph Garwe, Philipp Meyer, Laura Brune und Christoph Hönnige, Institut für Politikwissenschaft, Leibniz Universität Hannover</h4>

</div>


<p><br /></p>
<p><img src="logo_IPW.png" /></p>
<p><br /></p>
<div id="einleitung" class="section level1">
<h1>1. Einleitung</h1>
<p>Nachdem wir die Datensätze, mit denen wir in diesem Kurs arbeiten werden, in der vorherigen Sitzung kennengelernt und eingeladen haben, wollen wir in dieser Sitzung die darin enthaltenen Variablen so anpassen, dass wir unsere Analysen durchführen können. Dabei sprechen wir vom Recodieren der Variablen.</p>
</div>
<div id="einladen-der-datensätze" class="section level1">
<h1>2. Einladen der Datensätze</h1>
<p>Von nun an müssen wir am Beginn jedes Skriptes die Datensätze, die wir verwenden, in den Workspace laden. Andernfalls stünden sie uns nicht zur Bearbeitung zur Verfügung. In dieser Sitzung benötigen wir den Datensatz der GLES zur Bundestagswahl 2017 (<code>gles</code>) und den Datensatz zu “Patterns of Democracy” (<code>lijphart</code>). Wie in der vergangenen Sitzung behandelt, müssen wir zunächst das Verzeichnis prüfen und ggf. auf den Speicherort festlegen, an dem die Datensätze abgespeichert sind.</p>
<pre class="r"><code>getwd()
setwd(&quot;eigener Pfad&quot;)</code></pre>
<p>Nun werden die Datensätze eingeladen. Da die Funktion zum Einladen des Fremdformats .sav <code>read.spss()</code> aus dem Paket <code>foreign</code> stammt, muss dieses zunächst geladen werden. <code>read.csv2()</code> ist eine Funktion aus dem Paket <code>base</code>, sodass kein besonderes Paket zu seiner Verwendung geladen werden muss.</p>
<pre class="r"><code>library(foreign)
gles &lt;- read.spss(file = &quot;ZA6801_de_v4-0-1.sav&quot;, to.data.frame = TRUE)
lijphart &lt;- read.csv2(&quot;Lijphart_Data_recode.csv&quot;)</code></pre>
<p>Wenn alles geklappt hat, sehen Sie rechts oben im <code>Global Environment</code> die beiden als Dataframes vorliegenden Datensätze <code>gles</code> mit 2112 Beobachtungen und 602 Variablen und <code>lijphart</code> mit 36 Beobachtungen und 74 Variablen. Variablen, die wir im Folgenden neu bilden, werden die Datensätze erweitern bzw. werden rechts an die Datensätze angehängt. Wenn wir vorliegende Variablen modifizieren, werden die Datensätze lediglich in ihrer bestehenden Form verändert. Beobachten und überwachen Sie also jeweils die Veränderungen der Datensätze im <code>Global Environment</code>. Die Veränderungen der einzelnen Variablen sollten Sie außerdem mittels <code>View()</code> nachvollziehen.</p>
</div>
<div id="variablen-der-gles" class="section level1">
<h1>3. Variablen der <code>gles</code></h1>
<p>Anhand der Wahlforschungsdaten der GLES wollen wir im weiteren Verlauf des Seminars die Wahlentscheidung der Befragten mittels sozio-demografischer Größen und politischer Einstellungen erklären. Dabei interessiert uns insbesondere, wie die Wahlentscheidung zugunsten der AfD erklärt werden kann. Außerdem werden wir versuchen, die Selbsteinstufung der Befragten entlang einer Links-Rechts-Achse zu erklären. Wir benötigen die folgenden Variablen: das Alter der Befragten, deren Geschlecht, Einkommen, Wohnort, subjektive Links-Rechts-Einstufung und die Angabe, ob sie bei der Bundestagswahl 2017 ihre Stimme für die Partei AfD abgegeben haben. Im Folgenden werden wir uns die Variablen jeweils einmal in der Form anschauen, in der sie im Datensatz vorkommen. Danach werden wir sie zu unseren Zwecken verändern. Wir beginnen mit den unabhängigen Variablen.</p>
<div id="alter" class="section level2">
<h2>3.1 Alter</h2>
<p>Das Alter der Befragten könnte einen Einfluss auf die Wahlentscheidung und die Position entlang einer gedachten Links-Rechts-Achse haben. Tatsächlich wurden die Befragten nicht ausdrücklich nach ihrem Alter gefragt, sondern nach ihrem Geburtsdatum (Schauen Sie mal in den Fragebogen, S. 11). Das Geburtsjahr ist dabei in der Variable <code>q2c</code>, einem Faktor, vercodet worden.</p>
<pre class="r"><code>class(gles$q2c)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>table(gles$q2c)</code></pre>
<pre><code>## 
## 1922 1923 1924 1925 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 
##    1    2    1    1    2    4    8    4    8   10    7   13   20   22   22   25 
## 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 
##   29   35   36   19   24   26   17   23   24   31   36   31   24   50   35   36 
## 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 
##   32   30   22   38   45   44   32   48   41   41   47   34   36   41   37   30 
## 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 
##   38   31   32   31   29   21   27   35   22   33   24   23   26   32   27   23 
## 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 
##   33   41   37   22   27   25   19   18   29   25   27   28   32   48   22</code></pre>
<p>Wir berechnen das Alter, indem wir das Geburtsjahr der Befragten von dem Jahr, in dem die Befragung stattfand, subtrahieren. Dazu müssen wir die Variable zunächst in einen numerischen Vektor umwandeln. Wenn man jedoch Faktoren direkt in numerische Vektoren umwandelt, werden die zugrunde liegenden Levels der Faktoren herangezogen und als numerische Werte interpretiert. Diese Levels ordnet <code>R</code> willkürlich zu, sodass wir sie (ohne Aufwand sie zu ordnen) nicht verwenden können (vgl. Sitzung 1).</p>
<pre class="r"><code>head(as.numeric(gles$q2c)) # nicht sinnvoll; durch `head()` nur die ersten Werte ausgegeben </code></pre>
<pre><code>## [1] 38 42 31 17 79 37</code></pre>
<p>Deshalb müssen wir den Faktor <code>q2c</code> etwas umständlich zuerst zu einem character-Vektor und danach zu einem numerischen Vektor umwandeln. Dazu verschachteln wir die Explicit-Coercion-Funktionen zu <code>as.numeric(as.character())</code>. Die numerischen Geburtsjahre speichern wir als <code>q2c_num</code>. Schließlich führen wir die Subtraktion durch. Das so berrechnete Alter speichern wir in einer neuen Variable <code>alter</code>, die wir an den Datensatz anfügen.</p>
<pre class="r"><code>q2c_num &lt;- as.numeric(as.character(gles$q2c))
gles$alter &lt;- 2017 - q2c_num # Warnung &quot;NA&#39;s introduced by coercion&quot; weil eine Person mit &quot;keine Angabe&quot; antwortete und das numerisch nicht interpretierbar ist
class(gles$alter)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>table(gles$alter)</code></pre>
<pre><code>## 
## 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 
## 22 48 32 28 27 25 29 18 19 25 27 22 37 41 33 23 27 32 26 23 24 33 22 35 27 21 
## 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 
## 29 31 32 31 38 30 37 41 36 34 47 41 41 48 32 44 45 38 22 30 32 36 35 50 24 31 
## 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 92 93 94 
## 36 31 24 23 17 26 24 19 36 35 29 25 22 22 20 13  7 10  8  4  8  4  2  1  1  2 
## 95 
##  1</code></pre>
<pre class="r"><code>summary(gles$alter)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
##   16.00   34.00   51.00   50.15   65.00   95.00       1</code></pre>
<pre class="r"><code>View(gles$alter)</code></pre>
<p>Wie die <code>summary()</code> zeigt, sind Personen zwischen 16 und 95 Jahren befragt worden, wobei der Median bei 51 Jahren und das arithmetische Mittel bei 50,15 Jahren liegt. Bei einer Person liegt keine Information über das Alter vor (<code>NA</code>), diese Person hat die Angabe verweigert (s.o.). <code>table()</code> zeigt, wie viele Personen mit einer bestimmten Jahreszahl jeweils enthalten sind, also z.B. 22 16-Jährige, 48 17-Jährige usw. Mit <code>View()</code> können wir die Variable inspizieren.</p>
</div>
<div id="geschlecht" class="section level2">
<h2>3.2 Geschlecht</h2>
<p>Womöglich hat das Geschlecht der Befragten einen Einfluss. Das Geschlecht der Befragten ist direkt erfasst worden und liegt als Faktor vor. Wir vergeben lediglich einen aussagekräftigen Variablennamen.</p>
<pre class="r"><code>names(gles)[names(gles) == &quot;q1&quot;] &lt;- &quot;geschlecht&quot;
table(gles$geschlecht)</code></pre>
<pre><code>## 
## maennlich  weiblich 
##      1097      1015</code></pre>
<p>Wie die <code>table()</code> zeigt, sind Männer in unserem Sample leicht überrepräsentiert.</p>
</div>
<div id="haushaltseinkommen" class="section level2">
<h2>3.3 Haushaltseinkommen</h2>
<p>Auch die wirtschaftliche Situation der Befragten könnte eine Rolle spielen. Das (Netto-)Haushaltseinkommen der Befragten ist in Kategorien abgefragt worden (siehe hierzu die Fragebogendokumentation, S. 206).</p>
<pre class="r"><code>table(gles$q192)</code></pre>
<pre><code>## 
##            unter 500 Euro    500 bis unter 750 Euro   750 bis unter 1000 Euro 
##                        19                        33                        62 
##  1000 bis unter 1250 Euro  1250 bis unter 1500 Euro  1500 bis unter 2000 Euro 
##                        85                       111                       231 
##  2000 bis unter 2500 Euro  2500 bis unter 3000 Euro  3000 bis unter 4000 Euro 
##                       262                       250                       310 
##  4000 bis unter 5000 Euro  5000 bis unter 7500 Euro 7500 bis unter 10000 Euro 
##                       189                       161                        38 
##       10000 Euro und mehr 
##                        18</code></pre>
<p>Da diese sehr kleinteilig sind, wollen wir sie neu zuschneiden. Die sieben neuen Kategorien lauten wie folgt: weniger als 1000 Euro, 1000 bis 1999 Euro, 2000 bis 2999 Euro, 3000 bis 3999 Euro, 4000 bis 4999 Euro, 5000 bis 7499 Euro und 7500 Euro und mehr.</p>
<p>Wir verwenden zur Indizierung wieder eckige Klammern, allerdings diesmal in Kombination mit dem logischen Oder <code>|</code>. Der nachfolgende Code sagt folgendes aus: Wenn <code>q192</code> die Ausprägung “unter 500 Euro” aufweist, <em>oder</em> wenn die Variable “500 bis unter 750 Euro” aufweist, <em>oder</em> wenn sie “750 bis unter 1000 Euro” aufweist, dann ordne <code>einkommen_cat</code> “weniger als 1000 Euro” zu. Für die anderen Kategorien geschieht dies analog. Machen Sie sich bewusst, dass der Inhalt der eckigen Klammern jeweils ein logischer Vektor mit <code>TRUE</code>- und <code>FALSE</code>-Aussagen ist. Wenn <code>TRUE</code>, dann wird <code>einkommen_cat</code> der String rechts von <code>&lt;-</code> zugewiesen.</p>
<p>Führen Sie zu Veranschaulichungszwecken diese Codezeile zunächst einzeln aus.</p>
<pre class="r"><code>gles$einkommen_cat[gles$q192 == &quot;unter 500 Euro&quot; |
                     gles$q192 == &quot;500 bis unter 750 Euro&quot; |
                     gles$q192 == &quot;750 bis unter 1000 Euro&quot;] &lt;- &quot;weniger als 1000&quot;</code></pre>
<p>Lassen Sie sich dann <code>View(gles$einkommen_cat)</code> ausgeben:</p>
<pre class="r"><code>View(gles$einkommen_cat)</code></pre>
<p>Sie sehen, dass <code>einkommen_cat</code> für die meisten Beobachtungen ein <code>NA</code> (“not available”) enthält. Das sind die Personen, deren Haushaltseinkommen 1000 Euro und mehr beträgt. Wenn Sie nun schrittweise die folgenden Codezeilen ausführen, verschwinden die <code>NA</code>s nach und nach.</p>
<pre class="r"><code>gles$einkommen_cat[gles$q192 == &quot;1000 bis unter 1250 Euro&quot; |
                     gles$q192 == &quot;1250 bis unter 1500 Euro&quot; |
                     gles$q192 == &quot;1500 bis unter 2000 Euro&quot;] &lt;- &quot;1000 bis 1999&quot;
gles$einkommen_cat[gles$q192 == &quot;2000 bis unter 2500 Euro&quot; |
                     gles$q192 == &quot;2500 bis unter 3000 Euro&quot;] &lt;- &quot;2000 bis 2999&quot;
gles$einkommen_cat[gles$q192 == &quot;3000 bis unter 4000 Euro&quot;] &lt;- &quot;3000 bis 3999&quot;
gles$einkommen_cat[gles$q192 == &quot;4000 bis unter 5000 Euro&quot;] &lt;- &quot;4000 bis 4999&quot;
gles$einkommen_cat[gles$q192 == &quot;5000 bis unter 7500 Euro&quot;] &lt;- &quot;5000 bis 7499&quot;
gles$einkommen_cat[gles$q192 == &quot;7500 bis unter 10000 Euro&quot; |
                     gles$q192 == &quot;10000 Euro und mehr&quot;] &lt;- &quot;7500 und mehr&quot;</code></pre>
<p>Wenn Sie alle Zeilen ausgeführt haben, werden immernoch einige <code>NA</code>s übrig bleiben. Das sind die Personen, die die Aussage verweigert haben, die ihr Haushaltseinkommen nicht kannten, oder deren Haushaltseinkommen aus anderen Gründen nicht vorlag. Die Variable sieht schließlich so aus:</p>
<pre class="r"><code>table(gles$einkommen_cat)</code></pre>
<pre><code>## 
##    1000 bis 1999    2000 bis 2999    3000 bis 3999    4000 bis 4999 
##              427              512              310              189 
##    5000 bis 7499    7500 und mehr weniger als 1000 
##              161               56              114</code></pre>
<p>Dabei fällt uns auf, dass die eigentlich niedrigste Kategorie “weniger als 1000” im Output als letzte erscheint. Um die ursprünglich richtige Ordnung herzustellen, wandeln wir <code>einkommen_cat</code> in einen Faktor um und ordnen die Levels händisch.</p>
<pre class="r"><code>gles$einkommen_cat &lt;- factor(gles$einkommen_cat,
                                levels = c(&quot;weniger als 1000&quot;,
                                           &quot;1000 bis 1999&quot;,
                                           &quot;2000 bis 2999&quot;,
                                           &quot;3000 bis 3999&quot;,
                                           &quot;4000 bis 4999&quot;,
                                           &quot;5000 bis 7499&quot;,
                                           &quot;7500 und mehr&quot;))

table(gles$einkommen_cat)</code></pre>
<pre><code>## 
## weniger als 1000    1000 bis 1999    2000 bis 2999    3000 bis 3999 
##              114              427              512              310 
##    4000 bis 4999    5000 bis 7499    7500 und mehr 
##              189              161               56</code></pre>
<p>Nun ist die Variable richtig geordnet.</p>
<p>Wir können das Haushaltseinkommen auch als kontinuierliche Variable behandeln, da es in der vorliegenden Kodierweise sieben Ausprägungen aufweist. Dazu verändern wir die eben erstellte Variable wie folgt:</p>
<pre class="r"><code>gles$einkommen_num[gles$einkommen_cat == &quot;weniger als 1000&quot;] &lt;- 1
gles$einkommen_num[gles$einkommen_cat == &quot;1000 bis 1999&quot;] &lt;- 2
gles$einkommen_num[gles$einkommen_cat == &quot;2000 bis 2999&quot;] &lt;- 3
gles$einkommen_num[gles$einkommen_cat == &quot;3000 bis 3999&quot;] &lt;- 4
gles$einkommen_num[gles$einkommen_cat == &quot;4000 bis 4999&quot;] &lt;- 5
gles$einkommen_num[gles$einkommen_cat == &quot;5000 bis 7499&quot;] &lt;- 6
gles$einkommen_num[gles$einkommen_cat == &quot;7500 und mehr&quot;] &lt;- 7
table(gles$einkommen_num)</code></pre>
<pre><code>## 
##   1   2   3   4   5   6   7 
## 114 427 512 310 189 161  56</code></pre>
<p>Wie Sie sehen, entsprechen sich die Kategorien von <code>einkommen_cat</code> und <code>einkommen_num</code> in Bezug auf die Fallzahl pro Kategorie.</p>
</div>
<div id="wohnort" class="section level2">
<h2>3.4 Wohnort</h2>
<p>Außerdem könnte der Wohnort der Befragten einen Einfluss auf die politische Position oder die Wahlentscheidung haben. In diesem Fall sind die in der Ursprungsform vorliegenden Kategorien ausreichend. Allerdings sind die Labels recht unhandlich, weshalb wir sie umbenennen.</p>
<pre class="r"><code>table(gles$q197)</code></pre>
<pre><code>## 
##       laendliche Gegend oder Dorf    kleine oder mittelgrosse Stadt 
##                               766                               762 
## Vorstadt/ Vorort einer Grossstadt                        Grossstadt 
##                               147                               437</code></pre>
<pre class="r"><code>gles$wohnort[gles$q197 == &quot;Grossstadt&quot;] &lt;- &quot;Großstadt&quot;
gles$wohnort[gles$q197 == &quot;kleine oder mittelgrosse Stadt&quot;] &lt;- &quot;Kleinstadt&quot;
gles$wohnort[gles$q197 == &quot;laendliche Gegend oder Dorf&quot;] &lt;- &quot;Land&quot;
gles$wohnort[gles$q197 == &quot;Vorstadt/ Vorort einer Grossstadt&quot;] &lt;- &quot;Vorstadt&quot;
table(gles$wohnort)</code></pre>
<pre><code>## 
##  Großstadt Kleinstadt       Land   Vorstadt 
##        437        762        766        147</code></pre>
<p>Da lediglich die Kategorienamen und nicht die Datenstruktur angepasst wurden, hat sich am Zuschnitt der Kategorien nichts geändert.</p>
</div>
<div id="links-rechts-selbsteinstufung" class="section level2">
<h2>3.5 Links-Rechts-Selbsteinstufung</h2>
<p>Schließlich kommen wir zu den unabhängigen Variablen unserer Analysen. Bei der Links-Rechts-Selbsteinstufung wurden die Befragten aufgefordert, ihre Position anhand einer 11-stufigen Links-Rechts-Skala einzuschätzen. Wir schauen uns wieder zunächst mit der <code>table()</code> an, wie sich die Befragten einordnen.</p>
<pre class="r"><code>table(gles$q32)</code></pre>
<pre><code>## 
##   1 links         2         3         4         5         6         7         8 
##        53       105       263       249       354       552       184       118 
##         9        10 11 rechts 
##        50        13        23</code></pre>
<p>Auch in diesem Fall belassen wir die Kategorisierung (zunächst) in ihrer Ursprungsform, wandeln die Variable jedoch in einen numerischen Vektor um und kodieren die als Strings enthaltenden Ausprägungen zu numerisch interpretierbaren Zahlen.</p>
<pre class="r"><code>gles$LiRe &lt;- as.character(gles$q32)
gles$LiRe[gles$LiRe == &quot;1 links&quot;] &lt;- &quot;1&quot;
gles$LiRe[gles$LiRe == &quot;11 rechts&quot;] &lt;- &quot;11&quot;
gles$LiRe &lt;- as.numeric(gles$LiRe)</code></pre>
<p>Auch hier muss der Faktor <code>q32</code> zunächst in einen character-Vektor umgewandelt werden (dabei wird er als neues Objekt <code>LiRe</code> gespeichert), damit man ihn sinnvoll umkodieren und schließlich in einen numerischen Vektor umwandeln kann.</p>
<p>Die Links-Rechts-Selbsteinstufung wollen wir des Weiteren etwas aggregieren, sodass mehrere ihrer Kategorien zusammengefasst werden. Die Kategorien eins und zwei sollen in der neuen Kategorie “links”, die Kategorien drei und vier in der Kategorie “moderat links”, die Kategorien fünf, sechs und sieben in der Kategorie “mittig”, die Kategorien acht und neun in der Kategorie “moderat rechts” und die Kategorien 10 und 11 in der Kategorie “rechts” zusammengefasst werden. Wir erstellen die aggregierte Variable ausgehend von der eben gebildeten Variable <code>LiRe</code> und verwenden die Vergleichsoperatoren <code>&gt;=</code> (größer-gleich) und <code>&lt;=</code> (kleiner-gleich).</p>
<pre class="r"><code>gles$LiRe_cat[gles$LiRe &gt;= 1 &amp;
                gles$LiRe &lt;= 2] &lt;- &quot;links&quot;
gles$LiRe_cat[gles$LiRe &gt;= 3 &amp;
                gles$LiRe &lt;= 4] &lt;- &quot;moderat links&quot;
gles$LiRe_cat[gles$LiRe &gt;= 5 &amp;
                gles$LiRe &lt;= 7] &lt;- &quot;mittig&quot;
gles$LiRe_cat[gles$LiRe &gt;= 8 &amp;
                gles$LiRe &lt;= 9] &lt;- &quot;moderat rechts&quot;
gles$LiRe_cat[gles$LiRe &gt;= 10 &amp;
                gles$LiRe &lt;= 11] &lt;- &quot;rechts&quot;
table(gles$LiRe_cat)</code></pre>
<pre><code>## 
##          links         mittig  moderat links moderat rechts         rechts 
##            158           1090            512            168             36</code></pre>
<p>Durch die Aggregierung hat die neue Variable weniger Kategorien, jedoch mehr Fälle pro Kategorie. Allerdings sind die Kategorien ähnlich wie beim kategorialen Haushaltseinkommen durcheinandergeraten. Wir stellen die richtige Ordnung her, indem wir sie zu einem Faktor umwandeln und die Levels händisch ordnen.</p>
<pre class="r"><code>gles$LiRe_cat &lt;- factor(gles$LiRe_cat,
                                levels = c(&quot;links&quot;,
                                           &quot;moderat links&quot;,
                                           &quot;mittig&quot;,
                                           &quot;moderat rechts&quot;,
                                           &quot;rechts&quot;))

table(gles$LiRe_cat)</code></pre>
<pre><code>## 
##          links  moderat links         mittig moderat rechts         rechts 
##            158            512           1090            168             36</code></pre>
<p>Mit <code>LiRe</code> und <code>LiRe_cat</code> stehen uns nun zwei unabhängige Variablen zur Verfügung anhand derer wir die Links-Rechts-Selbsteinstufung der Befragten messen können.</p>
</div>
<div id="afd-wahl" class="section level2">
<h2>3.6 AfD-Wahl</h2>
<p>Schließlich benötigen wir eine Variable, die eine Aussage darüber trifft, ob eine befragte Person die AfD gewählt oder nicht gewählt hat. Bei solchen Variablen, die eine Aussage darüber treffen, ob etwas zutrifft oder nicht, sprechen wir von <em>dichotomen Variablen</em>. Dichotome Variablen vercoden den Wert 1, wenn etwas zutrifft und den Wert 0, wenn etwas nicht zutrifft. Die dichotome abhängige Variable zur AfD-Wahl bilden wir aus der Variable <code>q19ba</code>, die die berichtete Wahlentscheidung der Befragten enthält.</p>
<pre class="r"><code>table(gles$q19ba)</code></pre>
<pre><code>## 
##                          CDU/CSU                              CDU 
##                              504                                0 
##                              CSU                              SPD 
##                                0                              338 
##                              FDP                           GRUENE 
##                              200                              225 
##                        DIE LINKE                               BP 
##                              188                                0 
##                             BüSo                              DDP 
##                                0                                0 
##                       Die GRAUEN                       Die PARTEI 
##                                0                                0 
##                    DIE VIOLETTEN                          FAMILIE 
##                                0                                0 
##                    Freie Waehler                            GRAUE 
##                                0                                0 
## Grundeinkommen - Volksentscheide                              KPD 
##                                0                                0 
##                             MLPD                              NPD 
##                                0                                0 
##                            NSDAP                             oedp 
##                                0                                0 
##                              PBC                          PIRATEN 
##                                0                                0 
##                           Pro DM                          RENTNER 
##                                0                                0 
##                              REP                              RRP 
##                                0                                0 
##                              SED                 Tierschutzpartei 
##                                0                                0 
##                              UDP                  Volksabstimmung 
##                                0                                0 
##                          ZENTRUM                              UBP 
##                                0                                0 
##                             LDPD                              DBD 
##                                0                                0 
##                             DNVP                           GB/BHE 
##                                0                                0 
##                             NDPD              PARTEI DER VERNUNFT 
##                                0                                0 
##                       Bergpartei                              AfD 
##                                0                              162 
##                       DIE RECHTE                AD-Demokraten NRW 
##                                0                                0 
##                              BGE                        V-Partei3 
##                                0                                0 
##                               MG                               DM 
##                                0                                0 
##                              DiB                         Sonstige 
##                                0                                0 
##                    andere Partei                   Einzelkandidat 
##                               73                                0 
##                     keine Partei                    alle Parteien 
##                                0                                0 
##            mit mehreren Parteien 
##                                0</code></pre>
<pre class="r"><code>View(gles$q19ba)</code></pre>
<p>Wie zu erkennen ist, sind viele Kategorien nicht besetzt. Uns interessiert nun lediglich, ob eine Person die AfD gewählt hat oder nicht. Entsprechend wird in der neuen Variable <code>AfD.Wahl</code> Personen, die die AfD gewählt haben, eine 1 zugewiesen, während Personen, die eine andere Partei als die AfD gewählt haben, eine 0 zugewiesen wird. Wir verwenden <code>==</code> (gleich) und <code>!=</code> (ungleich).</p>
<pre class="r"><code>gles$AfD.Wahl[gles$q19ba == &quot;AfD&quot;] &lt;- 1
gles$AfD.Wahl[gles$q19ba != &quot;AfD&quot;] &lt;- 0</code></pre>
<p>Die neue Variable beinhaltet jetzt ausschließlich Einsen und Nullen. Wenn in <code>q19ba</code> keine Information über die Wahlentscheidung vorliegt (<code>NA</code>), beinhaltet allerdings auch die neue gebildete Variable <code>NA</code>.</p>
<pre class="r"><code>table(gles$AfD.Wahl)</code></pre>
<pre><code>## 
##    0    1 
## 1528  162</code></pre>
<pre class="r"><code>View(gles$AfD.Wahl)</code></pre>
</div>
</div>
<div id="variablen-aus-lijphart" class="section level1">
<h1>4. Variablen aus <code>lijphart</code></h1>
<p>Die Variablen des Datensatzes zu “Patterns of Democracy” werden im weiteren Verlauf dieses Kurses in der Form verwendet, in der sie ursprünglich vorliegen. Wir müssen sie also nicht recodieren. Allerdings liegen sie als character-Vektoren vor und müssen zu numerischen Vektoren umgewandelt werden. Das sei hier beispielhaft für die Variable <code>enpp4510</code> dargestellt, die die Effective Number of Parliamentary Parties in den Jahren 1945 bis 2010 für alle Länder enthält.</p>
<pre class="r"><code>class(lijphart$enpp4510)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>table(lijphart$enpp4510)</code></pre>
<pre><code>## 
## 1.38 1.67 1.68 1.69 1.87 1.99 2.16 2.22 2.27 2.28 2.39 2.52 2.66 2.67 2.68 2.85 
##    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    2 
## 2.89 3.09 3.13 3.15 3.26 3.47 3.48 3.62 3.64 3.72 4.40 4.57 4.72 4.80 4.84 4.87 
##    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1 
## 5.04 5.18 5.20 
##    1    1    1</code></pre>
<pre class="r"><code>summary(lijphart$enpp4510)</code></pre>
<pre><code>##    Length     Class      Mode 
##        36 character character</code></pre>
<p>Wie der Output der Funktionen <code>table()</code> und <code>summary()</code> zeigen, ist die Variable in dieser Form nicht sinnvoll zu interpretieren. Wir wandeln sie entsprechend um:</p>
<pre class="r"><code>lijphart$enpp4510 &lt;- as.numeric(lijphart$enpp4510)
summary(lijphart$enpp4510)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.380   2.277   2.990   3.192   3.890   5.200</code></pre>
<p>Anders als beim GLES überschreiben wir hier die Ursprungsvariable bzw. bilden keine neue Variable. Das hat damit zu tun, dass die Variable eigentlich numerisch sein müsste, wir sie also “reparieren” anstatt sie für unsere Zwecke anzupassen. So gehen wir mit allen Variablen vor, die wir im Kurs verwenden werden. Für den Gallagher-Index zur Messung der Disproportionalität von Wahlsystemen:</p>
<pre class="r"><code>lijphart$disprop4510 &lt;- as.numeric(lijphart$disprop4510)
summary(lijphart$disprop4510)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.210   3.252   7.140   8.546  14.305  21.970</code></pre>
<p>Für den Bikameralismus-Index:</p>
<pre class="r"><code>lijphart$bicam4510 &lt;- as.numeric(lijphart$bicam4510)
summary(lijphart$bicam4510)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.000   1.075   2.000   2.214   3.000   4.000</code></pre>
<p>Für den Anteil von Minimal-Winning-Koalition mit einer Partei, der zur Messung des Kabinettstyps herangezogen wird:</p>
<pre class="r"><code>lijphart$minwin_one_part4510 &lt;- as.numeric(lijphart$minwin_one_part4510)
summary(lijphart$minwin_one_part4510)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    4.00   37.67   55.05   60.32   86.60  100.00</code></pre>
<p>Sowie für die Kabinettsdauer, mithilfe derer die Exekutivdominanz operationalisiert wird:</p>
<pre class="r"><code>lijphart$exe_dom4510 &lt;- as.numeric(lijphart$exe_dom4510)
summary(lijphart$exe_dom4510)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.000   3.223   4.305   5.348   8.078   9.900</code></pre>
</div>
<div id="zusammenfassung" class="section level1">
<h1>5. Zusammenfassung</h1>
<p>Variablen der GLES haben wir geprüft und umkodiert. Dabei haben wir die Datenmanipulationen jeweils mit <code>table()</code>, <code>summary()</code> und <code>View()</code> nachvollzogen. Bestehende Variablen wurden in ihrer Ursprungsform belassen, während recodierte Variablen an den Datensatz angehängt wurden. Er beinhaltet nun 609 Variablen. Die Variablen aus dem Datensatz zu “Patterns of Democracy”, die wir in unseren Analysen verwenden werden, wurden lediglich zu numerischen Vektoren umgewandelt. Sie wurden nicht in Form neuer Objekte gespeichert, sondern überschrieben. Dieser Datensatz hat sich in seinem Umfang somit nicht verändert.</p>
</div>
<div id="aufgaben" class="section level1">
<h1>6. Aufgaben</h1>
<ol style="list-style-type: decimal">
<li>Suchen Sie im Fragebogen der GLES nach einer geeigneten Variable zur Messung der schulischen Bildung der Befragten. Diese sollte Information über die Schulabschlüsse der Befragten enthalten.</li>
<li>Bilden Sie eine Variable <code>schulab</code> mit den folgenden Kategorien: Hochschulreife, Fachhochschulreife, Realschule, Hauptschule, kein Abschluss. Inspizieren Sie die Variable und stellen Sie sicher, dass bei Befragten, die einen anderen oder noch keinen Schulabschluss haben, ein <code>NA</code> vercodet wurde.</li>
<li>Bilden Sie aus <code>einkommen_num</code> eine Variable <code>einkommen_cat1</code>, die vier Kategorien hat: “weniger als 2000”, “2000 bis unter 4000”, “4000 bis unter 7500”, “7500 und mehr”. Nutzen Sie die Vergleichsoperatoren <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> &amp; <code>&lt;=</code> sowie den logischen Operator <code>&amp;</code>.</li>
<li>Bilden Sie eine identische Variable <code>einkommen_cat2</code>. Nutzen Sie diesmal die Operatoren <code>==</code> und <code>|</code>. Inspizieren Sie, ob beide tatsächlich identisch sind.</li>
<li>Suchen Sie per Google eine Funktion, mit der Sie prüfen können, ob Objekte/Variablen identisch sind. Wenden Sie diese Funktion auf <code>einkommen_cat1</code> und <code>einkommen_cat2</code> an.</li>
<li>Was ist an der Berechnung des Alters der Befragten nicht ganz richtig?</li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
