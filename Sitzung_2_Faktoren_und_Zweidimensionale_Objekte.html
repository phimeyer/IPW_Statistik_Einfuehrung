<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Christoph Garwe, Philipp Meyer und Christoph Hönnige, Institut für Politikwissenschaft, Leibniz Universität Hannover" />


<title>Politikwissenschaftliche Methoden mit R - Sitzung 2: Faktoren und Zweidimensionale Objekte</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-sm-12 col-md-4 col-lg-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-sm-12 col-md-8 col-lg-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Personal Website</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="Sitzung_1_Einführung.html">Sitzung_1_Einführung</a>
</li>
<li>
  <a href="Sitzung_2_Faktoren_und_Zweidimensionale_Objekte.html">Sitzung_2_Faktoren_und_Zweidimensionale_Objekte</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Politikwissenschaftliche Methoden mit R - Sitzung 2: Faktoren und Zweidimensionale Objekte</h1>
<h4 class="author">Christoph Garwe, Philipp Meyer und Christoph Hönnige, Institut für Politikwissenschaft, Leibniz Universität Hannover</h4>

</div>


<p>Nachdem die vergangene Sitzung einen breit angelegten Einstieg in <code>R</code> als Programm der statistischen Datenanalyse gegeben hat, wollen wir von dieser Sitzung an auf die Arbeit mit Datensätzen einschwenken. Dazu werden wir in der nächsten Sitzung die Datensätze, mit denen wir die Analysen durchführen werden, kennenlernen und in <code>R</code> nutzbar machen. Zuvor wollen wir uns in dieser Sitzung einen Überblick über die zweidimensionalen Objektklassen verschaffen, in denen Datensätze üblicherweise in <code>R</code> vorliegen. Außerdem lernen wir mit Faktoren eine weiteren eindimensionale Objektklasse kennen.</p>
<div id="matrix" class="section level1">
<h1>1. <code>matrix</code></h1>
<p>Matrizen sind Vektoren mit einer Besonderheit: Sie haben zwei Dimensionen (Vektoren besitzen nur eine). Daten in Form von Matrizen sind also in Zeilen und Spalten geordnet, genau wie bei einer klassischen Tabelle. Das hat zur Folge, dass innerhalb einer Matrix jede Zeile, genauso wie jede Spalte, gleich lang sein muss. Wäre eine Spalte oder Zeile länger oder kürzer, käme es zu leeren Zellen innerhalb der Matrix und damit könnte <code>R</code> nicht umgehen.</p>
<p>Ansonsten verhalten sich Matrizen so wie Vektoren. Das bezieht sich insbesondere darauf, dass sie nur eine Klasse von Objekten gleichzeitig beinhalten können. Die Elemente einer Matrix können also z.B. entweder nur <em>character</em>-Vektoren oder nur numerisch sein.</p>
<div id="eine-matrix-erstellen" class="section level2">
<h2>1.1 eine Matrix erstellen</h2>
<p>Wir bilden eine Matrix in <code>R</code> so:</p>
<pre class="r"><code>m &lt;- matrix(data = 1:6, nrow = 2, ncol = 3)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<p>Die Funktion <code>matrix()</code> beinhaltet die Argumente <code>data</code>, mit dem die Daten innerhalb der Matrix spezifiziert werden, <code>nrow</code> (für “number of rows”), mit dem die Anzahl der Zeilen, und <code>ncol</code> (“number of columns”), mit dem die Anzahl der Spalten bestimmt werden. Bei sechs Elementen und zwei Zeilen folgt logisch, dass die Matrix drei Spalten haben muss. Deshalb kann man sich das letzte Argument auch sparen:</p>
<pre class="r"><code>m &lt;- matrix(data = 1:6, nrow = 2)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<p>Wir sehen, dass <code>R</code> die Matrix Spalte für Spalte mit Werten versehen hat: 1 und 2 stehen in der ersten Spalte, 3 und 4 in der zweiten Spalte und 5 und 6 in der dritten Spalte. Die Art und Weise, wie <code>R</code> beim “Füllen” der Matrix vorgeht, lässt sich über das Argument <code>byrow</code> bestimmen, dessen default (Standardeinstellung) <code>FALSE</code> ist. Wir setzen <code>byrow</code> auf <code>TRUE</code>.</p>
<pre class="r"><code>m &lt;- matrix(1:6, nrow = 2, byrow = TRUE)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6</code></pre>
<p>Nun füllt <code>R</code> die Matrix zeilenweise mit Werten, sodass 1, 2 und 3 in der ersten und 4, 5 und 6 in der zweiten Zeile stehen.</p>
</div>
<div id="cbind-und-rbind" class="section level2">
<h2>1.2 <code>cbind()</code> und <code>rbind()</code></h2>
<p>Anders als zuvor, können Matrizen auch erzeugt werden, indem Vektoren “zusammengebunden” werden. Dazu verwenden wir <code>cbind()</code> (“column bind”, Spalten verbinden) und <code>rbind()</code> (“row bind”, Zeilen verbinden).</p>
<pre class="r"><code>abc &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)   # Bilden eines character vector &quot;abc&quot;, der die Buchstaben &quot;a&quot;, &quot;b&quot; und &quot;c&quot; enthält
def &lt;- c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)   # Bilden eines zweiten character vector &quot;def&quot;, der die Buchstaben &quot;d&quot;, &quot;e&quot; und &quot;f&quot; enthält
bind &lt;- cbind(abc, def)     # &quot;Zusammenbinden&quot; der Vektoren a und b als Spalten
bind</code></pre>
<pre><code>##      abc def
## [1,] &quot;a&quot; &quot;d&quot;
## [2,] &quot;b&quot; &quot;e&quot;
## [3,] &quot;c&quot; &quot;f&quot;</code></pre>
<p>Das funktioniert natürlich genauso (und findet in der Praxis häufiger Anwendung) für numerische Vektoren:</p>
<pre class="r"><code>x &lt;- 6:9                # Bilden eines numerischen Vektors
y &lt;- 20:23              # Bilden eines zweiten numerischen Vektors
cbind(x, y)             # Zusammenbinden als Spalten</code></pre>
<pre><code>##      x  y
## [1,] 6 20
## [2,] 7 21
## [3,] 8 22
## [4,] 9 23</code></pre>
<pre class="r"><code>rbind(x, y)             # Zusammenbinden als Zeilen</code></pre>
<pre><code>##   [,1] [,2] [,3] [,4]
## x    6    7    8    9
## y   20   21   22   23</code></pre>
<p>Wie wir im Output sehen, bleiben die Namen der Vektoren <code>x</code> und <code>y</code> als Zeilen- bzw. Spaltennamen in der Matrix erhalten. Mithilfe von <code>rownames()</code> und <code>colnames()</code> können wir die Zeilen- und Spaltennamen verändern.</p>
<pre class="r"><code>z &lt;- cbind(x, y)        # Erstellen der Matrix z aus den Vektoren x und y (als Spalten)
colnames(z) &lt;- c(&quot;einstellig&quot;, &quot;zweistellig&quot;)   # Zuweisen der Spaltennamen
z                       # Ausgeben von z um zu prüfen, ob es geklappt hat</code></pre>
<pre><code>##      einstellig zweistellig
## [1,]          6          20
## [2,]          7          21
## [3,]          8          22
## [4,]          9          23</code></pre>
<pre class="r"><code>rownames(z) &lt;- c(&quot;erste&quot;, &quot;zweite&quot;, &quot;dritte&quot;, &quot;vierte&quot;) # Zuweisen der Zeilennamen
z                       # nochmal ausgeben</code></pre>
<pre><code>##        einstellig zweistellig
## erste           6          20
## zweite          7          21
## dritte          8          22
## vierte          9          23</code></pre>
<p><code>rbind()</code> und <code>cbind()</code> können in gleicher Weise verwendet werden, um Dataframes zu verbinden oder zu erweitern. Worum es sich dabei handelt, erfahren wir jetzt.</p>
</div>
</div>
<div id="data-frame" class="section level1">
<h1>2. <code>data frame</code></h1>
<p>Dataframes sind die übliche Form, in der tabellarische Daten in <code>R</code> gespeichert werden und damit ein wichtiger Typ von Objekten. Wenn wir in der nächsten Sitzung die Datensätze, die wir in diesem Kurs untersuchen wollen, einlesen, werden sie in Form von Dataframes vorliegen. Während wir diese Dataframes mit Funktionen zum Einladen von extern verfügbaren Datensätzen erstellen werden (insbesondere <code>read.csv</code>, dazu mehr in der nächsten Sitzung), können wir Dataframes auch direkt mithilfe der Funktion <code>data.frame()</code> bilden.</p>
<div id="dataframes-händisch-erstellen" class="section level2">
<h2>2.1 Dataframes händisch erstellen</h2>
<p>Genau wie bei Matrizen müssen auch bei Dataframes alle Zeilen und Spalten die gleiche Länge aufweisen. Im Gegensatz zur Matrix ist es bei Dataframes allerdings möglich, Elemente unterschiedlicher Klassen miteinander zu kombinieren. Dataframes werden gebildet, indem wir in den Klammern der Funktion <code>data.frame()</code> die in ihnen zusammengefassten Spalten (Variablen) nacheinander mit ihrem Namen und Inhalt nennen. In diesem Beispiel für die Variablen <code>a</code> und <code>b</code>:</p>
<pre class="r"><code>df &lt;- data.frame(a = 1:4, b = c(TRUE, TRUE, FALSE, FALSE))
df</code></pre>
<pre><code>##   a     b
## 1 1  TRUE
## 2 2  TRUE
## 3 3 FALSE
## 4 4 FALSE</code></pre>
<p>Wenn wir <code>df</code> abschicken, zeigt der Output die Variablennamen <code>a</code> und <code>b</code> oben und eine automatische Nummerierung der Spalten links.</p>
<p>In einem etwas größeren Beispiel liegt uns ein Auszug aus (fiktiven) Daten eines Experiments vor. Der hier gebildete Dataframe fasst Information zu einer Identifikationsnummer (“id”), dazu, ob es sich um die Experimental- oder Kontrollgruppe handelt (“bedingung”), zur Soziodemografie (“geschlecht”, “alter”), sowie zu den Ergebnissen des Experiments zu zwei unterschiedlichen Zeitpunkten (“wert_t1”, “wert_t2”) für sechs teilnehmende Personen zusammen.</p>
<pre class="r"><code>df &lt;- data.frame(id = 1:6,
                 bedingung = c(&quot;E&quot;, &quot;E&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;E&quot;),
                 geschlecht = c(&quot;M&quot;, &quot;M&quot;, &quot;W&quot;, &quot;M&quot;, &quot;W&quot;, &quot;W&quot;),
                 alter = c(17,  19,  22,  18,  16,  21),
                 wert_t1 = c(8.0, 6.0, 7.5, 6.8, 8.0, 6.4),
                 wert_t2 = c(8.3, 6.4, 7.7, 6.3, 7.5, 6.4))
df</code></pre>
<pre><code>##   id bedingung geschlecht alter wert_t1 wert_t2
## 1  1         E          M    17     8.0     8.3
## 2  2         E          M    19     6.0     6.4
## 3  3         C          W    22     7.5     7.7
## 4  4         C          M    18     6.8     6.3
## 5  5         C          W    16     8.0     7.5
## 6  6         E          W    21     6.4     6.4</code></pre>
<p>Nun wird der Vorzug von Dataframes ersichtlich: Sie ermöglichen es, dass wir Information unterschiedlicher Skalenniveaus kombinieren. Für jede Beobachtung steht also jede Form von Information zur Verfügung, die benötigt wird.</p>
</div>
<div id="dataframes-und-matrizen-umwandeln" class="section level2">
<h2>2.2 Dataframes und Matrizen umwandeln</h2>
<p>In einer Matrix wäre das nicht möglich. Anstatt dessen werden alle enthaltenen Elemente mittels implicit coercion zu character Strings (wenn die Funktion <code>as.matrix()</code> verwendet wird) oder numerischen Werten (wenn die Funktion <code>data.matrix()</code> verwendet wird) umgewandelt:</p>
<pre class="r"><code>dfm &lt;- as.matrix(df) # Umwandlung des Dataframe df in eine Matrix dfm auf die &quot;klassiche&quot; Art und Weise mit as.matrix(): Umwandlung in Characters
dfm</code></pre>
<pre><code>##      id  bedingung geschlecht alter wert_t1 wert_t2
## [1,] &quot;1&quot; &quot;E&quot;       &quot;M&quot;        &quot;17&quot;  &quot;8.0&quot;   &quot;8.3&quot;  
## [2,] &quot;2&quot; &quot;E&quot;       &quot;M&quot;        &quot;19&quot;  &quot;6.0&quot;   &quot;6.4&quot;  
## [3,] &quot;3&quot; &quot;C&quot;       &quot;W&quot;        &quot;22&quot;  &quot;7.5&quot;   &quot;7.7&quot;  
## [4,] &quot;4&quot; &quot;C&quot;       &quot;M&quot;        &quot;18&quot;  &quot;6.8&quot;   &quot;6.3&quot;  
## [5,] &quot;5&quot; &quot;C&quot;       &quot;W&quot;        &quot;16&quot;  &quot;8.0&quot;   &quot;7.5&quot;  
## [6,] &quot;6&quot; &quot;E&quot;       &quot;W&quot;        &quot;21&quot;  &quot;6.4&quot;   &quot;6.4&quot;</code></pre>
<pre class="r"><code>dfm &lt;- data.matrix(df) # &quot;intelligentere&quot; Variante: Umwandlung in numerische Werte.
dfm</code></pre>
<pre><code>##      id bedingung geschlecht alter wert_t1 wert_t2
## [1,]  1         2          1    17     8.0     8.3
## [2,]  2         2          1    19     6.0     6.4
## [3,]  3         1          2    22     7.5     7.7
## [4,]  4         1          1    18     6.8     6.3
## [5,]  5         1          2    16     8.0     7.5
## [6,]  6         2          2    21     6.4     6.4</code></pre>
<p>Wie wir sehen, kam es bei der Umwandlung in eine Matrix zu dem typischen Informationsverlust durch implicit coercion. Sinnvoller (da nicht mit Informationsverlust verbunden) ist die Umwandlung von Matrizen in Dataframes mit der Funktion <code>as.data.frame()</code>:</p>
<pre class="r"><code>dfz &lt;- as.data.frame(z) # Matrix &quot;z&quot; (siehe oben) wird zu einem Dataframe umgewandelt und als neues Objekt &quot;dfz&quot; gespeichert
dfz</code></pre>
<pre><code>##        einstellig zweistellig
## erste           6          20
## zweite          7          21
## dritte          8          22
## vierte          9          23</code></pre>
</div>
<div id="variablen--und-zeilennamen-abfragen-und-verändern" class="section level2">
<h2>2.3 Variablen- und Zeilennamen abfragen und verändern</h2>
<p>Häufig ist es sinnvoll, sich die in einem Datensatz enthaltenen Variablen anzuschauen, zumindest dann, wenn es sich (anders als hier) um einen fremden Datensatz handelt. Die Namen der Variablen (also der Spalten eines Dataframes) können wir uns mit <code>names()</code> anzeigen lassen.</p>
<pre class="r"><code>names(df)</code></pre>
<pre><code>## [1] &quot;id&quot;         &quot;bedingung&quot;  &quot;geschlecht&quot; &quot;alter&quot;      &quot;wert_t1&quot;    &quot;wert_t2&quot;</code></pre>
<p>Genauso können wir die Variablennamen mittels <code>names()</code> verändern. Erscheint uns beispielsweise die Bezeichnung “id” als zu wenig informativ, sodass wir einen aussagekräftigeren Variablennamen wünschen, können wir sie folgendermaßen anpassen:</p>
<pre class="r"><code>names(df)[1] &lt;- &quot;identifikation&quot; # Die erste Spalte des Dataframes &quot;df&quot; durch die &quot;1&quot; in den eckigen Klammern identifiziert
df</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17     8.0     8.3
## 2              2         E          M    19     6.0     6.4
## 3              3         C          W    22     7.5     7.7
## 4              4         C          M    18     6.8     6.3
## 5              5         C          W    16     8.0     7.5
## 6              6         E          W    21     6.4     6.4</code></pre>
<p>Die Zeilennamen von Dataframes können mit der Funktion <code>row.names()</code> ausgegeben und verändert werden.</p>
<pre class="r"><code>row.names(df)</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot;</code></pre>
<p>Da Zeilennamen bei Dataframes jedoch regelmäßig laufende Nummern (Zeilennummern) sind, die uns die Orientierung im Datenstatz erleichtern, sollten sie in der Regel nicht verändert werden. Der Vollständigkeit halber ein Beispiel für eine (nicht sinnvolle) Veränderung der Zeilennamen:</p>
<pre class="r"><code>beispiel &lt;- df  # Dataframe &quot;df&quot; wird als &quot;beispiel&quot; gespeichert
row.names(beispiel) &lt;- 7:12 # Veränderung der Zeilennamen zu den Ziffern sieben bis 12
beispiel  # Zeilennummern nun von sieben bis 12</code></pre>
<pre><code>##    identifikation bedingung geschlecht alter wert_t1 wert_t2
## 7               1         E          M    17     8.0     8.3
## 8               2         E          M    19     6.0     6.4
## 9               3         C          W    22     7.5     7.7
## 10              4         C          M    18     6.8     6.3
## 11              5         C          W    16     8.0     7.5
## 12              6         E          W    21     6.4     6.4</code></pre>
</div>
</div>
<div id="zeilen-spalten-und-zellen-auswählen" class="section level1">
<h1>3. Zeilen, Spalten und Zellen auswählen</h1>
<p>Häufig benötigt man einen Datensatz nicht in seiner Gänze, sondern möchte bestimmte Zeilen oder Spalten bzw. einzelne Zellen auswählen. Wir können einzelne Elemente innerhalb von mehrdimensionalen Objekten auf unterschiedliche Arten auswählen.</p>
<div id="auswählen-mithilfe-der-eckigen-klammern" class="section level2">
<h2>3.1 Auswählen mithilfe der eckigen Klammern <code>[]</code></h2>
<p>Beim Output von Matrizen (solange wir die Spalten-/Zeilennamen nicht angepasst haben) konnten wir sehen, dass links von den Zeilen und oben über den Spalten die eckigen Klammern <code>[]</code> zu sehen sind.</p>
<pre class="r"><code>m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6</code></pre>
<p>Mithilfe der eckigen Klammern werden in <code>R</code> Zeilen (Zahl vor dem Komma) und Spalten (Zahl nach dem Komma) identifiziert. Mithilfe der Identifizierung von Reihen und Spalten in den eckigen Klammern können Elemente innerhalb von Matrizen ausgegeben werden. Wenn wir z. B. die erste Spalte der oben erstellten Matrix <code>m</code> ausgeben möchten, schreiben wir</p>
<pre class="r"><code>m[, 1]</code></pre>
<pre><code>## [1] 1 4</code></pre>
<p>und für die erste Zeile entsprechend</p>
<pre class="r"><code>m[1, ]</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<p>Wenn wir an einer bestimmten Zelle innerhalb der Matrix interessiert sind (hier an der Zelle in der zweiten Zeile der ersten Spalte), schreiben wir</p>
<pre class="r"><code>m[2, 1]</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Diese Form der Auswahl gilt analog für Dataframes. Auch Zeilen und Spalten sowie Zellen des Dataframes <code>df</code> können so ausgegeben werden:</p>
<pre class="r"><code>df[, 3] # dritte Spalte</code></pre>
<pre><code>## [1] &quot;M&quot; &quot;M&quot; &quot;W&quot; &quot;M&quot; &quot;W&quot; &quot;W&quot;</code></pre>
<pre class="r"><code>df[, -1] # jede Spalte außer der ersten</code></pre>
<pre><code>##   bedingung geschlecht alter wert_t1 wert_t2
## 1         E          M    17     8.0     8.3
## 2         E          M    19     6.0     6.4
## 3         C          W    22     7.5     7.7
## 4         C          M    18     6.8     6.3
## 5         C          W    16     8.0     7.5
## 6         E          W    21     6.4     6.4</code></pre>
<pre class="r"><code>df[4, ] # vierte Zeile</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 4              4         C          M    18     6.8     6.3</code></pre>
<pre class="r"><code>df[2, 5]  # Zelle in der zweiten Reihe und vierten Spalte</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>df[, c(1, 4)] # erste und vierte Spalte (nur die Variablen &quot;identifikation&quot; und &quot;alter&quot;)</code></pre>
<pre><code>##   identifikation alter
## 1              1    17
## 2              2    19
## 3              3    22
## 4              4    18
## 5              5    16
## 6              6    21</code></pre>
<pre class="r"><code>df[4:6, ]  # Zeilen 4 bis 6 (die letzten drei Beobachtungen)</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 4              4         C          M    18     6.8     6.3
## 5              5         C          W    16     8.0     7.5
## 6              6         E          W    21     6.4     6.4</code></pre>
<p>Wenn Zeilen-/Spaltennamen vorliegen und wir das Zählen leid sind, können wir genauso diese Namen zur Indizierung mithilfe der eckigen Klammern verwenden.</p>
<pre class="r"><code>z[, &quot;einstellig&quot;] # Spalte mit Namen &quot;einstellig&quot;</code></pre>
<pre><code>##  erste zweite dritte vierte 
##      6      7      8      9</code></pre>
<pre class="r"><code>df[, c(&quot;bedingung&quot;, &quot;geschlecht&quot;)]  # Variablen &quot;bedingung&quot; und &quot;geschlecht&quot;</code></pre>
<pre><code>##   bedingung geschlecht
## 1         E          M
## 2         E          M
## 3         C          W
## 4         C          M
## 5         C          W
## 6         E          W</code></pre>
</div>
<div id="auswählen-mithilfe-des-dollarzeichens" class="section level2">
<h2>3.2. Auswählen mithilfe des Dollarzeichens <code>$</code></h2>
<p>Nur für Dataframes (nicht für Matrizen) empfiehlt sich die Verwendung des Dollarzeichens <code>$</code>. Dabei wird ganz einfach der Variablenname mit dem Dollarzeichen an den Datensatz angehängt.</p>
<pre class="r"><code>df$alter</code></pre>
<pre><code>## [1] 17 19 22 18 16 21</code></pre>
<pre class="r"><code>df$wert_t1</code></pre>
<pre><code>## [1] 8.0 6.0 7.5 6.8 8.0 6.4</code></pre>
<p>Die Verwendung des Dollarzeichens ist weniger fehleranfällig, da wir den Namen der ausgewählten Variable (Spalte) explizit nennen müssen. Dabei hilft uns <code>RStudio</code>, indem es die Variablennamen automatisch vervollständigt. Unser Code wird durch Nennung der Variablennamen außerdem anschaulicher und verständlicher (zumindest, solange wir aussagekräftige Variablennamen verwenden).</p>
</div>
<div id="auswählen-mit-logischen-vektoren-und-werten" class="section level2">
<h2>3.3 Auswählen mit logischen Vektoren und Werten</h2>
<p>Neben der Identifizierung von Zeilen und Spalten können wir auch einzelne Werte innerhalb einer Spalte bzw. Variable auswählen. Häufig ist von Interesse, bei welchen Beobachtungen eine Variable einen bestimmten Wert annimmt. Wir können also beim Auswählen noch detaillierter vorgehen, als zuvor gezeigt. Und zwar können wir inhaltliche Information (die Merkmalsausprägungen) bei der Auswahl miteinbeziehen. Wenn uns besipielsweise interessiert, welche Probanden des Experiments der Experimentalgruppe angehören, gehen wir folgendermaßen vor.</p>
<ol style="list-style-type: decimal">
<li>Wir bilden einen logischen Vektor (Sitzung 1), der eine Aussage darüber trifft, für welche Beobachtungen unter “bedingung” ein “E” eingetragen wurde (technisch: Wann ist die Aussage, dass “bedingung” gleich “E” ist, wahr?).</li>
</ol>
<pre class="r"><code>df$bedingung == &quot;E&quot;</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE</code></pre>
<p>Ergebnis: Die Variable “bedingung” nimmt in der ersten, zweiten und sechsten Zeile den Wert “E” an.</p>
<ol start="2" style="list-style-type: decimal">
<li>Diesen logischen Vektor wenden wir auf den Datensatz <code>df</code> an indem wir ihn in die eckigen Klammern <strong>vor</strong> das Komma schreiben. Also dorthin, wo Information zu den Zeilen abgerufen wird. Die Anweisung an <code>R</code> lautet dann: Nenne mir die Zeilen, für die die Aussage, dass “bedingung” gleich “E” ist, zutrifft.</li>
</ol>
<pre class="r"><code>df[df$bedingung == &quot;E&quot;, ]</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17     8.0     8.3
## 2              2         E          M    19     6.0     6.4
## 6              6         E          W    21     6.4     6.4</code></pre>
<p>Genauso könnten uns nur die Probanden interessieren, die (1) der Experimentalgruppe angehören und, die (2) einen “wert_t1” aufweisen, der größer als 6,0 ist. Wir formulieren also zwei Bedingungen.</p>
<pre class="r"><code>df[df$bedingung == &quot;E&quot; &amp; df$wert_t1 &gt; 6.0, ]</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17     8.0     8.3
## 6              6         E          W    21     6.4     6.4</code></pre>
<p>Wenn wir wissen wollten, welche Probanden der Experimentalgruppe männlich sind, formulieren wir genauso zwei Bedingungen:</p>
<pre class="r"><code>df[df$bedingung == &quot;E&quot; &amp; df$geschlecht == &quot;M&quot;, ]</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17       8     8.3
## 2              2         E          M    19       6     6.4</code></pre>
<p>In diesen Beispielen beziehen wir die Identifizierung von Zeilen, die ausgewählt werden sollen, jeweils auf den gesamten Datensatz (vor der eckigen Klammer steht “df”). Wir können die Identifizierung jedoch genauso nur auf einzelne Spalten/Variablen beziehen (also nicht nur “df”, sondern zusätzlich einen Variablennamen vor die eckigen Klammern schreiben). Wenn wir ein Element einer Variable auswählen möchten, haben wir es wieder mit einem eindimensionalen Objekt zu tun, denn einzelne Variablen/Spalten haben nur eine Dimension. Deshalb gehen wir genauso vor wie in Sitzung 1 bei der Auswahl von Elementen innerhalb von Vektoren. D.h., das Komma in der eckigen Klammer entfällt.</p>
<pre class="r"><code>df$geschlecht[df$bedingung == &quot;E&quot;]</code></pre>
<pre><code>## [1] &quot;M&quot; &quot;M&quot; &quot;W&quot;</code></pre>
<p>Auswählen von Zeilen, Spalten und Zellen kann informativen Zwecken dienen, jedoch wollen wir häufig einen Datensatz anhand bestimmter Auswahlkriterien zuschneiden. Genauer gesagt, wollen wir nun die Erstellung von Subsets behandeln.</p>
</div>
<div id="subsets-erstellen" class="section level2">
<h2>3.4 Subsets erstellen</h2>
<p>Die gute Nachricht vorweg: Das Anspruchsvollste beim Erstellen von Subsets (Teilmengen) ist das Auswählen von Elementen und das haben wir schon behandelt. Nun geht es lediglich darum, die so definierten Subsets als für sich genommene Objekte zu speichern. Auch das Erstellen neuer Objekte haben wir schon kennengelernt. Dazu verwenden wir den Operator <code>&lt;-</code> .</p>
<div id="subsetten-mithilfe-logischer-vektoren" class="section level3">
<h3>3.4.1 Subsetten mithilfe logischer Vektoren</h3>
<p>Wenn wir also einen Teildatensatz erstellen möchten, der nur die Experimentalgruppe enthält, schreiben wir:</p>
<pre class="r"><code>subset &lt;- df[df$bedingung == &quot;E&quot;, ]
subset</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17     8.0     8.3
## 2              2         E          M    19     6.0     6.4
## 6              6         E          W    21     6.4     6.4</code></pre>
<p><code>subset</code> ist nun das Objekt, in dem der verkürzte Datensatz gespeichert wurde. Oder aber es interessieren uns nur die Erwachsenen Probanden:</p>
<pre class="r"><code>subset &lt;- df[df$alter &gt;= 18, ]
subset</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 2              2         E          M    19     6.0     6.4
## 3              3         C          W    22     7.5     7.7
## 4              4         C          M    18     6.8     6.3
## 6              6         E          W    21     6.4     6.4</code></pre>
<p>Diese Subsets sind durch die inhaltliche Merkmalsausprägung der Variablen “bedingung” und “alter” bestimmt. Natürlich können wir auch einfach einzelne Spalten oder Zeilen auswählen (s.o.):</p>
<pre class="r"><code>subset &lt;- df$alter # Subset nur der Variable &quot;alter&quot;
subset</code></pre>
<pre><code>## [1] 17 19 22 18 16 21</code></pre>
<pre class="r"><code>subset &lt;- df[4:6, ] # Subset der vierten bis sechsten Zeile   
subset</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 4              4         C          M    18     6.8     6.3
## 5              5         C          W    16     8.0     7.5
## 6              6         E          W    21     6.4     6.4</code></pre>
<pre class="r"><code>subset &lt;- df[, c(1, 3)] # Subset der ersten und der dritten Spalte
subset</code></pre>
<pre><code>##   identifikation geschlecht
## 1              1          M
## 2              2          M
## 3              3          W
## 4              4          M
## 5              5          W
## 6              6          W</code></pre>
<pre class="r"><code>subset &lt;- df[, c(&quot;identifikation&quot;, &quot;geschlecht&quot;, &quot;alter&quot;)]  # Subset der Variablen &quot;identifikation&quot;, &quot;geschlecht&quot;, und &quot;alter&quot;
subset</code></pre>
<pre><code>##   identifikation geschlecht alter
## 1              1          M    17
## 2              2          M    19
## 3              3          W    22
## 4              4          M    18
## 5              5          W    16
## 6              6          W    21</code></pre>
</div>
<div id="subset" class="section level3">
<h3>3.4.2 <code>subset()</code></h3>
<p>Eine zweite gute Nachricht: Wir können uns das aufwendige Subsetten mittels eckiger Klammern vereinfachen. base-<code>R</code> besitzt nämlich eine eigenständige Funktion zum Erstellen von Subsets mit der naheliegenden Bezeichnung <code>subset()</code>. <code>subset()</code> ermöglicht die Reduktion eines Datensatzes auf ausgewählte Zeilen mit dem Argument <code>subset</code> und auf bestimmte Variablen (Spalten) mit dem Argument <code>select</code>.</p>
<pre class="r"><code>?subset</code></pre>
<p>Wir verkürzen den Datensatz auf die Variable “alter”:</p>
<pre class="r"><code>subset &lt;- subset(df, select = alter)
subset</code></pre>
<pre><code>##   alter
## 1    17
## 2    19
## 3    22
## 4    18
## 5    16
## 6    21</code></pre>
<p>… auf die Variablen “identifikation”, “geschlecht” und “alter”:</p>
<pre class="r"><code>subset &lt;- subset(df, select = c(identifikation, geschlecht, alter))
subset</code></pre>
<pre><code>##   identifikation geschlecht alter
## 1              1          M    17
## 2              2          M    19
## 3              3          W    22
## 4              4          M    18
## 5              5          W    16
## 6              6          W    21</code></pre>
<p>… auf die Zeilen vier bis sechs:</p>
<pre class="r"><code>subset &lt;- subset(df, subset = identifikation &gt;= 4)
subset</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 4              4         C          M    18     6.8     6.3
## 5              5         C          W    16     8.0     7.5
## 6              6         E          W    21     6.4     6.4</code></pre>
<p>… auf die Minderjährigen:</p>
<pre class="r"><code>subset &lt;- subset(df, alter &lt; 18) # hier wird das Argument &quot;subset&quot; nicht ausdrücklich genannt
subset</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17       8     8.3
## 5              5         C          W    16       8     7.5</code></pre>
<p>Das Argument <code>select</code> benötigt eine Indizierung der Variablen, während das Argument <code>subset</code> inhaltliche Information zu den Merkmalsausprägungen benötigt (“&gt;= 4”, “&lt; 18”).</p>
</div>
</div>
</div>
<div id="faktoren" class="section level1">
<h1>4. Faktoren</h1>
<p>Abschließend möchten wir mit den Faktoren einen wichtigen eindimensionalen Objekttyp behandeln. Das Besondere bei Faktoren ist, dass sie Labels verwenden. Mithilfe beschreibender Labels wird unsere Datenanalyse anschaulicher: Eine Variable, die die Labels “klein”, “mittel” und “groß” verwendet, ist intuitiv verständlicher als eine Variable, die anstatt dessen nur die Werte 1, 2 und 3 verwendet. Dadurch bekommen wir eine Beschreibung zu den Daten.</p>
<p>Faktoren erstellen wir mit der Funktion <code>factor()</code>. Unser Faktor <code>x</code> soll einmal den Wert “klein”, zweimal den Wert “mittel” und dreimal den Wert “groß” beinhalten. Wir nutzen <code>c()</code> und zählen die Werte des Faktors auf.</p>
<pre class="r"><code>x &lt;- factor(c(&quot;klein&quot;, &quot;mittel&quot;, &quot;mittel&quot;, &quot;groß&quot;, &quot;groß&quot;, &quot;groß&quot;))
x</code></pre>
<pre><code>## [1] klein  mittel mittel groß   groß   groß  
## Levels: groß klein mittel</code></pre>
<p>Nachdem wir uns <code>x</code> haben ausgeben lassen, sehen wir im Output, dass tatsächlich “klein” einmal, “mittel” zweimal und “groß” dreimal vorkommt. Die Levels werden außerdem noch einmal ausgegeben.</p>
<p>Das Besondere bei Faktoren ist, dass sich hinter den Labels (“klein”, “mittel” &amp; “groß”) numerische Werte verbergen. Sie ermöglichen mathematische Operationen, obwohl das mit den Labels an sich (die keine Zahlen sind) eigentlich nicht möglich wäre. Die zugrunde liegenden numerischen Werte können wir uns mithilfe von <code>unclass(x)</code> ausgeben lassen.</p>
<pre class="r"><code>unclass(x)</code></pre>
<pre><code>## [1] 2 3 3 1 1 1
## attr(,&quot;levels&quot;)
## [1] &quot;groß&quot;   &quot;klein&quot;  &quot;mittel&quot;</code></pre>
<pre class="r"><code>x</code></pre>
<pre><code>## [1] klein  mittel mittel groß   groß   groß  
## Levels: groß klein mittel</code></pre>
<p>Wenn wir den Output von <code>unclass(x)</code> und <code>x</code> vergleichen, stellen wir fest, dass “klein” der Wert 2, “mittel” der Wert 3 und “groß” der Wert 1 zugewiesen wurde. Das liegt daran, dass <code>R</code> sich bei der Zuordnung der Werte an der alphabetischen Reihung orientiert. Demnach käme erst G, dann M und dann K, was einer inhaltlich sinnvollen Ordnung unserer Levels widerspricht. Deshalb werden wir <code>x</code> nun so ordnen, dass “klein” &lt; “mittel” &lt; “groß”. Dazu verwenden wir das Argument <code>levels =</code> innerhalb der Funktion <code>factor()</code> und spezifizieren dort mithilfe der Funktion <code>c()</code> die Levels in der richtigen Ordnung.</p>
<pre class="r"><code>x &lt;- factor(c(&quot;klein&quot;, &quot;mittel&quot;, &quot;mittel&quot;, &quot;groß&quot;, &quot;groß&quot;, &quot;groß&quot;),
            levels = c(&quot;klein&quot;, &quot;mittel&quot;, &quot;groß&quot;))
unclass(x)</code></pre>
<pre><code>## [1] 1 2 2 3 3 3
## attr(,&quot;levels&quot;)
## [1] &quot;klein&quot;  &quot;mittel&quot; &quot;groß&quot;</code></pre>
<pre class="r"><code>x</code></pre>
<pre><code>## [1] klein  mittel mittel groß   groß   groß  
## Levels: klein mittel groß</code></pre>
<p>Jetzt entsprechen sich interne Werte und externe Labels.</p>
<p>Da Dataframes Variablen unterschiedlicher Klassen enthalten können, können Variablen auch als Faktoren vorliegen. Mit <code>as.factor()</code> können wir Vektoren zu Faktoren umwandeln. Das gilt auch für Variablen innerhalb von Dataframes. Innerhalb des Dataframes <code>df</code> ist das nur für die <em>character</em>-Variablen <code>bedingung</code> und <code>geschlecht</code> sinnvoll, da deren Inhalt als Labels interpretiert werden kann.</p>
<pre class="r"><code>df$geschlecht &lt;- as.factor(df$geschlecht)
df$geschlecht</code></pre>
<pre><code>## [1] M M W M W W
## Levels: M W</code></pre>
<pre class="r"><code>unclass(df$geschlecht)</code></pre>
<pre><code>## [1] 1 1 2 1 2 2
## attr(,&quot;levels&quot;)
## [1] &quot;M&quot; &quot;W&quot;</code></pre>
<pre class="r"><code>df</code></pre>
<pre><code>##   identifikation bedingung geschlecht alter wert_t1 wert_t2
## 1              1         E          M    17     8.0     8.3
## 2              2         E          M    19     6.0     6.4
## 3              3         C          W    22     7.5     7.7
## 4              4         C          M    18     6.8     6.3
## 5              5         C          W    16     8.0     7.5
## 6              6         E          W    21     6.4     6.4</code></pre>
</div>
<div id="zusammenfassung" class="section level1">
<h1>4. Zusammenfassung</h1>
<p>Matrizen und Dataframes sind nützliche zweidimensionale Objekte in <code>R</code>. Zeilen und Spalten müssen bei beiden Objekttypen jeweils gleich lang sein. Matrizen können wie Vektoren nur Elemente derselben Klasse beinhalten. In Dataframes können Variablen unterschiedlicher Klassen abgespeichert werden. Wissenschaftliche Datensätze liegen üblicherweise in Form von Dataframes vor. Wir können mehrdimensionale Objekte aus eindimensionalen Vektoren bilden, indem wir sie “zusammenbinden”. Elemente innerhalb von Matrizen und Dataframes können mit eckigen Klammern, Elemente von Dataframes mit dem Dollarzeichen sowie mit Vergleichen und logischen Operatoren ausgewählt werden. Anhand ausgewählter Objekte können Subsets mithilfe der klassischen Identifizierung oder der Funktion <code>subset()</code> gebildet werden. Faktoren stellen eine weitere Klasse eindimensionaler Objekte dar. Faktoren vergeben zugrunde liegenden Werten Labels.</p>
</div>
<div id="aufgaben" class="section level1">
<h1>5. Aufgaben</h1>
<ol style="list-style-type: decimal">
<li>Erstellen Sie zwei Matrizen, die beliebige 12 Werte beinhalten: a) mit drei Zeilen und Spalte für Spalte mit Werten versehen; b) mit zwei Spalten und Zeile für Zeile mit Werten versehen. Schreiben Sie effizienten Code, indem Sie jeweils nur die notwendigen Argumente erwähnen.</li>
<li>Erstellen Sie einen character-Vektor “p”, der die Namen der im 19. Deutschen Bundestag vertretenen Parteien enthält. Ordnen Sie den Vektor nach dem Mandatsanteil der Parteien beginnend mit dem größten Anteil. Erstellen Sie außerdem einen numerischen Vektor “a”, der die Mandatsanteile (gerundet auf eine Nachkommastelle) der Parteien enthält. Orientieren Sie sich an der Ordnung von “p”. Erstellen Sie eine Matrix, indem Sie beide Vektoren als Spalten verbinden. Inspizieren Sie die erstellte Matrix. Information finden Sie hier: <a href="https://www.bundestag.de/resource/blob/196106/b4daa14a76f53a3d58892a6373259a9d/Kapitel_01_16_Stimmenanteil_-_Mandatsanteil-data.pdf" class="uri">https://www.bundestag.de/resource/blob/196106/b4daa14a76f53a3d58892a6373259a9d/Kapitel_01_16_Stimmenanteil_-_Mandatsanteil-data.pdf</a></li>
<li>Wandeln Sie die unter 2. erstellte Matrix in einen Dataframe um. Prüfen Sie die Klasse der beiden Variablen des Dataframe. wandeln Sie sie ggf. in ein angemessenes Datenformat um. Geben Sie beiden Variablen sinnvolle Namen.</li>
<li>Erstellen Sie Subsets für die folgenden potenziellen Koalitionen und speichern Sie sie in Objekten mit den angegbenen Namen: CDU/CSU-SPD -&gt; “groko”, CDU/CSU-FDP-Grüne -&gt; “jamaika”. Summieren Sie jeweils den Mandatsanteil der möglichen Koalitionen (Tipp: im Tutorial zu Sitzung 1 finden Sie die entsprechende Funktion für das Summieren).</li>
<li>Erstellen Sie ein Subset aller Parteien, die mehr als 10 Prozent der Mandate auf sich vereinigen. Erstellen Sie dieses Subset einmal mithilfe eckiger Klammern und einmal mithilfe der Funktion <code>subset()</code>. Erstellen Sie außerdem ein Subset mit allen Parteien, die weniger Mandate auf sich vereinigen als die SPD. (Tipp: für Letzteres benötigen Sie einen logischen Vektor, selbst wenn Sie <code>subset()</code> verwenden.)</li>
<li>Erstellen Sie einen Faktor mit den Kategorien “Handy”, “Tablet”, “Laptop”, “PC”. Handys sollen zweimal, Tablets viermal, Laptops dreimal und PCs fünfmal vorkommen. Ordnen Sie den Faktor nach der Größe der Geräte von klein nach groß. Lassen Sie sich die <code>table()</code>und die <code>summary()</code> des Faktors ausgeben. Wandeln Sie den Faktor in einen numeric-Vektor um. Lassen Sie sich die <code>table()</code>und die <code>summary()</code> des Vektors ausgeben. Was hat sich im Output dieser Funktionen verändert?</li>
</ol>
</div>
<div id="lösungen" class="section level1">
<h1>6. Lösungen</h1>
<ol style="list-style-type: decimal">
<li></li>
</ol>
<ol style="list-style-type: lower-alpha">
<li></li>
</ol>
<pre class="r"><code>matrix(data = 10:21, nrow = 3)</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4]
## [1,]   10   13   16   19
## [2,]   11   14   17   20
## [3,]   12   15   18   21</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li></li>
</ol>
<pre class="r"><code>matrix(data = 10:21, ncol = 2, byrow = TRUE)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   10   11
## [2,]   12   13
## [3,]   14   15
## [4,]   16   17
## [5,]   18   19
## [6,]   20   21</code></pre>
<p>oder:</p>
<pre class="r"><code>matrix(data = 10:21, nrow = 6, byrow = TRUE)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]   10   11
## [2,]   12   13
## [3,]   14   15
## [4,]   16   17
## [5,]   18   19
## [6,]   20   21</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>(möglicherweise aktualisiert)</li>
</ol>
<pre class="r"><code>p &lt;- c(&quot;CDU/CSU&quot;, &quot;SPD&quot;, &quot;AfD&quot;, &quot;FDP&quot;, &quot;Linke&quot;, &quot;Grüne&quot;)
a &lt;- c(32.9, 20.5, 12.6, 10.7, 9.2, 8.9)
pa &lt;- cbind(p, a)</code></pre>
<ol start="3" style="list-style-type: decimal">
<li></li>
</ol>
<pre class="r"><code>padf &lt;- as.data.frame(pa)
class(padf$p)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>class(padf$a)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>padf$a &lt;- as.numeric(padf$a)
padf</code></pre>
<pre><code>##         p    a
## 1 CDU/CSU 32.9
## 2     SPD 20.5
## 3     AfD 12.6
## 4     FDP 10.7
## 5   Linke  9.2
## 6   Grüne  8.9</code></pre>
<pre class="r"><code>names(padf)[1] &lt;- &quot;parteien&quot;
names(padf)[2] &lt;- &quot;anteile&quot;
padf</code></pre>
<pre><code>##   parteien anteile
## 1  CDU/CSU    32.9
## 2      SPD    20.5
## 3      AfD    12.6
## 4      FDP    10.7
## 5    Linke     9.2
## 6    Grüne     8.9</code></pre>
<ol start="4" style="list-style-type: decimal">
<li></li>
</ol>
<pre class="r"><code>groko &lt;- subset(padf, subset = parteien == &quot;CDU/CSU&quot; | parteien == &quot;SPD&quot;)
sum(groko$anteile)</code></pre>
<pre><code>## [1] 53.4</code></pre>
<pre class="r"><code>jamaika &lt;- subset(padf, subset = parteien == &quot;CDU/CSU&quot; | parteien == &quot;Grüne&quot; |
                        parteien == &quot;FDP&quot;)
sum(jamaika$anteile)</code></pre>
<pre><code>## [1] 52.5</code></pre>
<ol start="5" style="list-style-type: decimal">
<li></li>
</ol>
<pre class="r"><code>padf[padf$anteile &gt; 10, ]</code></pre>
<pre><code>##   parteien anteile
## 1  CDU/CSU    32.9
## 2      SPD    20.5
## 3      AfD    12.6
## 4      FDP    10.7</code></pre>
<pre class="r"><code>subset(padf, subset = anteile &gt; 10)</code></pre>
<pre><code>##   parteien anteile
## 1  CDU/CSU    32.9
## 2      SPD    20.5
## 3      AfD    12.6
## 4      FDP    10.7</code></pre>
<pre class="r"><code>subset(padf, subset = anteile &lt; padf$anteile[padf$parteien == &quot;SPD&quot;])</code></pre>
<pre><code>##   parteien anteile
## 3      AfD    12.6
## 4      FDP    10.7
## 5    Linke     9.2
## 6    Grüne     8.9</code></pre>
<ol start="6" style="list-style-type: decimal">
<li></li>
</ol>
<pre class="r"><code>geraete &lt;- factor(c(&quot;Handy&quot;,&quot;Handy&quot;, &quot;Tablet&quot;, &quot;Tablet&quot;, &quot;Tablet&quot;, &quot;Tablet&quot;,
                   &quot;Laptop&quot;, &quot;Laptop&quot;, &quot;Laptop&quot;, &quot;PC&quot;, &quot;PC&quot;, &quot;PC&quot;, &quot;PC&quot;, &quot;PC&quot;),
                 levels = c(&quot;Handy&quot;, &quot;Tablet&quot;, &quot;Laptop&quot;, &quot;PC&quot;))

table(geraete)</code></pre>
<pre><code>## geraete
##  Handy Tablet Laptop     PC 
##      2      4      3      5</code></pre>
<pre class="r"><code>summary(geraete)</code></pre>
<pre><code>##  Handy Tablet Laptop     PC 
##      2      4      3      5</code></pre>
<pre class="r"><code>geraete &lt;- as.numeric(geraete)

table(geraete)</code></pre>
<pre><code>## geraete
## 1 2 3 4 
## 2 4 3 5</code></pre>
<pre class="r"><code>summary(geraete)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   1.000   2.000   3.000   2.786   4.000   4.000</code></pre>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
